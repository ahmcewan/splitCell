{
    "collab_server" : "",
    "contents" : "library(shiny)\nlibrary(reshape2)\nlibrary(xlsx)\nlibrary(DT)\nlibrary(dplyr)\nlibrary(readr)\noptions(shiny.sanitize.errors = FALSE)\n#Table used to select control wells\ntoggleTable <- matrix(\" \", nrow = 8, ncol = 12, dimnames = list(c(LETTERS[1:8]), seq.int(1, 12, 1)))\n\n\nlocalMaxima <- function(x) {\n  b <- diff(c(-Inf, x)) > 0L\n  rle(b)$lengths\n  b <- cumsum(rle(b)$lengths)\n  b <- b[seq.int(1L, length(b), 2L)]\n  if (x[[1]] == x[[2]]) {\n    b <- b[-1]\n  }\n  return(b)\n}\n#Table used to select control wells\ntoggleTable <- matrix(\" \", nrow = 8, ncol = 12, dimnames = list(c(LETTERS[1:8]), seq.int(1, 12, 1)))\n\n\nlocalMaxima <- function(x) {\n  b <- diff(c(-Inf, x)) > 0L\n  rle(b)$lengths\n  b <- cumsum(rle(b)$lengths)\n  b <- b[seq.int(1L, length(b), 2L)]\n  if (x[[1]] == x[[2]]) {\n    b <- b[-1]\n  }\n  return(b)\n}\n\nlocalMinima <- function(x) {\n  a <- diff(c(Inf, x)) > 0L\n  rle(a)$lengths\n  a <- cumsum(rle(a)$lengths)\n  a <- a[seq.int(1L, length(a), 2L)]\n  if (x[[1]] == x[[2]]) {\n    a <- a[-1]\n  }\n  return(a)\n}\n\n#ui\n\n\nui <- shinyUI(fluidPage(\n  mainPanel(\n    fileInput(\"files\",label = h4(\"Upload Data\"), multiple = TRUE, accept = c(\".csv\")),\n    fluidRow(column(3, uiOutput(\"edu\")),\n             column(3, uiOutput(\"dapi\")),\n             column(3, uiOutput(\"foci\")),\n             column(3, uiOutput(\"dapi_int\"))),\n    DT::dataTableOutput(\"userChoiceTbl\", width = \"50%\"),\n    tags$b(\"Cells Selected:\"),\n    verbatimTextOutput(\"selectedInfo\"), \n    fluidRow(column(6,h4(\"Density Plot of Mean Edu Intensity\"),plotOutput(\"edu_plot\")),\n             column(6,h4(\"Density Plot of Sum Dapi Intensity\"),plotOutput(\"dapi_plot\"))),\n    fluidRow(column(6,uiOutput(\"slider_edu\")),\n             column(3,uiOutput(\"slider_dapi\")),\n             column(3,uiOutput(\"slider_cut\"))),\n    downloadButton(\"downloadData\", \"Download\")\n    \n  )\n))\n\n\n#server\n#load data \nserver <- function(input, output, session){\n  dataset <- reactive({\n    validate(\n      need(input$files != \"\", \"\")\n    )\n    path_list <- as.list(input$files$datapath)\n    tbl_list <- lapply(input$files$datapath, read.table, header=TRUE, sep=\",\")\n    df <- do.call(rbind, tbl_list)\n    df <- df[order(df$WellName),]\n    col <- colnames(df)\n    updateSelectInput(session, inputId =\"edu\", choices =c(\"select\" , col ))\n    updateSelectInput(session, inputId =\"dapi\", choices =c(\"select\" , col ))\n    updateSelectInput(session, inputId =\"foci\", choices =c(\"select\" , col ))\n    updateSelectInput(session, inputId =\"dapi_int\", choices =c(\"select\" , col ))\n    list(df=data.frame(df))\n    \n  })\n  \n  #update selectInput wells\n  output$edu <- renderUI({\n    selectInput(\"edu\",\"Edu Mean\",choices = as.vector(dataset()$col))\n  })\n  output$dapi <- renderUI({\n    selectInput(\"dapi\",\"Dapi sum\",choices = as.vector(dataset()$col))\n  })\n  output$foci <- renderUI({\n    selectInput(\"foci\",\"Num spots\",choices = as.vector(dataset()$col))\n  })\n  output$dapi_int <- renderUI({\n    selectInput(\"dapi_int\",\"H2AX\",choices = as.vector(dataset()$col))\n  })\n  output$userChoiceTbl <- DT::renderDataTable({\n    datatable(toggleTable,options = list(dom = 't',ordering = F),selection = list(target = 'cell'),class = 'cell-border compact') %>% formatStyle(1:12, cursor = 'pointer')\n  })\n  \n  \n  cont_wells <- reactive({\n    validate(\n      need(input$userChoiceTbl_cells_selected != \"\", \"Please select control cells if applicable\")\n    )\n    wells <- input$userChoiceTbl_cells_selected\n    let <- LETTERS[wells[,1]]\n    num <- sort(wells[,2])\n    coordinates <- paste0(let,num)\n    list(coordinates = coordinates)\n  })\n  \n  #Outputs cells selected in datatable used to choose control wells  \n  output$selectedInfo <- renderPrint({\n    (cont_wells()$coordinates)\n  })\n  \n  reshape_cols <- function(x, cols=cols){\n    x$id <- with(x, ave(rep(1, nrow(x)), WellName, FUN = seq_along))\n    x <- dcast(data = x,formula = id~WellName,fun.aggregate = sum,value.var =cols,fill=-1)\n    x[x == -1] <-  NA\n    x <- x[-1]\n    dat <- x[,order(as.character(sub(\"[0-9]\",\"\",names(x))),as.integer(sub(\"[A-Z]\", \"\", names(x))))]\n    return(dat)\n  }\n  \n  subset_file <- reactive({\n    validate(\n      need(input$edu != \"\", \"\"),\n      need(input$dapi != \"\", \"\"),\n      need(input$foci != \"\", \"\"),\n      need(input$dapi_int != \"\", \"\")\n    )\n    if(input$edu %in% c(\"\",\"select\") | input$dapi %in% c(\"\",\"select\") | input$foci %in% c(\"\",\"select\") | input$dapi_int %in% c(\"\",\"select\")){\n      return(NULL)\n    }else{\n      rawData = dataset()$df\n      dat.cols <- c(\"WellName\", input$edu, input$dapi, input$foci, input$dapi_int)\n      dat.all <- dataset()$df[,colnames(dataset()$df) %in% dat.cols]\n      dat.cont <- dat.all\n      if (length(input$userChoiceTbl_cells_selected)!=0){\n        dat.cont <- dat.cont[rawData$WellName %in% cont_wells()$coordinates,]\n      }\n    }\n    list(dat.cont=dat.cont, \n         dat.all=dat.all)\n  })\n  \n  dat_g1 <- reactive({\n    validate(\n      need(input$edu != \"\", \"\"),\n      need(input$dapi != \"\", \"\"),\n      need(input$foci != \"\", \"\"),\n      need(input$dapi_int != \"\", \"\")\n    )\n    if (input$edu %in% c(\"\",\"select\") | input$dapi %in% c(\"\",\"select\") | input$foci %in% c(\"\",\"select\")| input$dapi_int %in% c(\"\",\"select\")){\n      return(NULL)\n    }else{\n    if(nrow(subset_file()$dat.cont)==0){\n    edu_values <- subset_file()$dat.all[[input$edu]]\n    }else{\n    edu_values <- subset_file()$dat.cont[[input$edu]]\n    }\n    cut <- quantile(edu_values, 0.75, na.rm=TRUE)\n    edu_values <- edu_values[edu_values < cut]\n    edu_dens <- density(edu_values, na.rm=TRUE)\n    dens <- edu_dens$y\n    #add 'max' localMaxima?\n    edu.max.x <-localMaxima(dens)[1]\n    edu.min.x <-localMinima(dens)\n    edu.min.thres <-edu.min.x[min(which(edu.min.x > edu.max.x))]\n    edu.min.x <- edu_dens$x[edu.min.thres]\n    \n\n    list(edu_values=edu_values, \n         dens=dens,\n         edu_dens=edu_dens,\n         edu.min.x=edu.min.x,\n         edu.max.x=edu.max.x,\n         edu.min.thres=edu.min.thres)\n}\n  })\n  \n  output$slider_edu <- renderUI({\n    validate(\n      need(input$edu != \"\", \"\"),\n      need(input$dapi != \"\", \"\"),\n      need(input$foci != \"\", \"\"),\n      need(input$dapi_int != \"\", \"\")\n    )\n    if (input$edu %in% c(\"\",\"select\") | input$dapi %in% c(\"\",\"select\") | input$foci %in% c(\"\",\"select\")| input$dapi_int %in% c(\"\",\"select\")){\n      return(NULL)\n    }else{\n    sliderInput(\"eduSlider\", \"Edu Threshold\", min=0, max=150, value=dat_g1()$edu.min.thres)\n    }\n  })\n  \n  dat_edu <- reactive({\n    if (input$edu %in% c(\"\",\"select\") | input$dapi %in% c(\"\",\"select\") | input$foci %in% c(\"\",\"select\")| input$dapi_int %in% c(\"\",\"select\")){\n      return(NULL)\n    }else{\n    validate(\n      need(input$edu != \"\", \"\"),\n      need(input$dapi != \"\", \"\"),\n      need(input$foci != \"\", \"\"),\n      need(input$dapi_int != \"\", \"\")\n    )\n      if(nrow(subset_file()$dat.cont)==0){\n        dat.cont <- subset_file()$dat.all\n      }else{\n        dat.cont <- subset_file()$dat.cont\n      }  \n    #create edu neg and edu positive populations\n    edu_threshold <- dat_g1()$edu_dens$x[input$eduSlider]\n    edu_neg_pooled_dapi <- dat.cont[dat_g1()$edu_values < edu_threshold,]\n    edu_pos_pooled_dapi <- dat.cont[dat_g1()$edu_values > edu_threshold,]\n    \n    #create edu neg and edu positive populations of all data based on control thresholds\n    edu_neg_pooled_dapi_all <- subset_file()$dat.all[dat_g1()$edu_values < edu_threshold,]\n    edu_pos_pooled_dapi_all <- subset_file()$dat.all[dat_g1()$edu_values >edu_threshold,]\n    \n    list(edu_neg_pooled_dapi=edu_neg_pooled_dapi, \n         edu_pos_pooled_dapi=edu_pos_pooled_dapi,\n         edu_neg_pooled_dapi_all=edu_neg_pooled_dapi_all,\n         edu_pos_pooled_dapi_all=edu_pos_pooled_dapi_all)\n    }\n  })\n  \n  dapi_threshold <- reactive({\n    if (input$edu %in% c(\"\",\"select\") | input$dapi %in% c(\"\",\"select\") | input$foci %in% c(\"\",\"select\")| input$dapi_int %in% c(\"\",\"select\")){\n      return(NULL)\n    }else{\n    validate(\n      need(input$edu != \"\", \"\"),\n      need(input$dapi != \"\", \"\"),\n      need(input$foci != \"\", \"\"),\n      need(input$dapi_int != \"\", \"\")\n    )\n    #get G1 and S/G2 threshold using dapi measurments\n    edu_neg <- dat_edu()$edu_neg_pooled_dapi\n    dapi_dens <- density(edu_neg[,input$dapi],na.rm=TRUE)\n    maxPeaks <- localMaxima(dapi_dens$y)\n    minValley <- localMinima(dapi_dens$y)\n    peak1 <- maxPeaks[match(max(dapi_dens$y[maxPeaks]),dapi_dens$y[maxPeaks])]\n    peak2 <- maxPeaks[match(max(dapi_dens$y[maxPeaks]),dapi_dens$y[maxPeaks]) + 1]\n    valley <- minValley[minValley < peak2 & minValley > peak1]\n    list(maxPeaks=maxPeaks,\n         dapi_dens=dapi_dens,\n         peak1=peak1,\n         peak2=peak2, \n         minValley=minValley,\n         valley=valley)\n    }\n  })\n  \n  \n  output$slider_dapi <- renderUI({\n    validate(\n      need(input$edu != \"\", \"\"),\n      need(input$dapi != \"\", \"\"),\n      need(input$foci != \"\", \"\"),\n      need(input$dapi_int != \"\", \"\")\n    )\n    if (input$edu %in% c(\"\",\"select\") | input$dapi %in% c(\"\",\"select\") | input$foci %in% c(\"\",\"select\")| input$dapi_int %in% c(\"\",\"select\")){\n      return(NULL)\n    }else{\n    validate(\n      need(input$edu != \"\", \"\"),\n      need(input$dapi != \"\", \"\"),\n      need(input$foci != \"\", \"\"),\n      need(input$dapi_int != \"\", \"\")\n    )\n    sliderInput(\"dapiSlider\", \"Dapi Threshold\", min=dapi_threshold()$peak1, max=dapi_threshold()$peak2, value=dapi_threshold()$valley)\n    }\n  })\n  \n  \n  output$slider_cut <- renderUI({\n    validate(\n      need(input$edu != \"\", \"\"),\n      need(input$dapi != \"\", \"\"),\n      need(input$foci != \"\", \"\"),\n      need(input$dapi_int != \"\", \"\")\n    )\n    if (input$edu %in% c(\"\",\"select\") | input$dapi %in% c(\"\",\"select\") | input$foci %in% c(\"\",\"select\")| input$dapi_int %in% c(\"\",\"select\")){\n      return(NULL)\n    }else{\n    sliderInput(\"cutSlider\", \"Dapi cutoff\", min=dapi_threshold()$peak1+50, max=dapi_threshold()$peak2+50, value=dapi_threshold()$valley+100)\n    }\n  })\n  \n  \n  downloads <- reactive({\n    validate(\n      need(input$edu != \"\", \"\"),\n      need(input$dapi != \"\", \"\"),\n      need(input$foci != \"\", \"\"),\n      need(input$dapi_int != \"\", \"\")\n    )\n    if (input$edu %in% c(\"\",\"select\") | input$dapi %in% c(\"\",\"select\") | input$foci %in% c(\"\",\"select\")| input$dapi_int %in% c(\"\",\"select\")){\n      return(NULL)\n    }else{\n    #get foci of edu + cells--edu pos\n    edu_pos_dapi <- dat_edu()$edu_pos_pooled_dapi_all[colnames(dat_edu()$edu_pos_pooled_dapi_all) %in% c(\"WellName\", input$dapi_int)]\n    edu_pos_int <- reshape_cols(edu_pos_dapi,cols=input$dapi_int)\n    #edu neg\n    edu_neg_dapi <- dat_edu()$edu_neg_pooled_dapi_all[colnames(dat_edu()$edu_neg_pooled_dapi_all) %in% c(\"WellName\", input$dapi_int)]\n    edu_neg_int <- reshape_cols(edu_neg_dapi,cols=input$dapi_int)\n    \n    #split data based on G1 and S/G2 threshold\n    cell_cycle_threshold <- dapi_threshold()$dapi_dens$x[input$dapiSlider]\n    dapi_cutoff <- dapi_threshold()$dapi_dens$x[input$cutSlider]\n    dapi_values <- dat_edu()$edu_neg_pooled_dapi[[input$dapi]]\n    dat.g1 <- dat_edu()$edu_neg_pooled_dapi_all[dapi_values < cell_cycle_threshold,]\n    dat.S <- dat_edu()$edu_neg_pooled_dapi_all[dapi_values > cell_cycle_threshold  & dapi_values < dapi_cutoff,]\n    edu_neg_g1_int <- reshape_cols(dat.g1, cols=input$dapi_int)\n    edu_neg_S_int <- reshape_cols(dat.S, cols=input$dapi_int)\n    dat.g1 <- reshape_cols(dat.g1,cols=input$foci)\n    dat.S <- reshape_cols(dat.S,cols=input$foci)\n    \n  \n    #edu positive foci\n    edu_pos_foci <- dat_edu()$edu_pos_pooled_dapi_all\n    edu_pos_foci <- reshape_cols(edu_pos_foci,cols=input$foci)\n    \n    \n    list(dat.g1=dat.g1, \n         dat.S=dat.S,\n         edu_pos_int=edu_pos_int,\n         edu_neg_int=edu_neg_int,\n         edu_pos_foci=edu_pos_foci,\n         edu_neg_g1_int=edu_neg_g1_int,\n         edu_neg_S_int=edu_neg_S_int)\n    }\n  })\n  \n  \n  output$rawData <- renderDataTable({\n    dat_edu()$edu_pos_pooled_dapi_all\n  },options = list(pageLength = 10))\n  \n  output$edu_plot <- renderPlot({\n    validate(\n      need(input$edu != \"\", \"\"),\n      need(input$dapi != \"\", \"\"),\n      need(input$foci != \"\", \"\"),\n      need(input$dapi_int != \"\", \"\")\n    )\n    if (input$edu %in% c(\"\",\"select\") | input$dapi %in% c(\"\",\"select\") | input$foci %in% c(\"\",\"select\")| input$dapi_int %in% c(\"\",\"select\")){\n      return(NULL)\n    }else{\n      plot(dat_g1()$dens,type=\"l\")\n      abline(v=input$eduSlider, col=\"red\")\n    }\n  })\n  \n  output$dapi_plot <- renderPlot({\n    \n    validate(\n      need(input$edu != \"\", \"\"),\n      need(input$dapi != \"\", \"\"),\n      need(input$foci != \"\", \"\"),\n      need(input$dapi_int != \"\", \"\")\n    )\n    if (input$edu %in% c(\"\",\"select\") | input$dapi %in% c(\"\",\"select\") | input$foci %in% c(\"\",\"select\")| input$dapi_int %in% c(\"\",\"select\")){\n      return(NULL)\n    }else{\n      plot(dapi_threshold()$dapi_dens$y, type=\"l\")\n      abline(v=input$dapiSlider, col=\"blue\")\n      abline(v=input$cutSlider, col=\"blue\")\n    }\n  })\n  \n  \n  ###download data###\n  ### remove #id column\n  output$downloadData <- downloadHandler(\n    filename = function(file) {\n      paste(\"data-\", Sys.Date(), \".xlsx\", sep=\"\")\n    },\n    content = function(con) {\n      write.xlsx2(downloads()$dat.g1, con, sheetName=\"edu_neg_G1_foci\", row.names=FALSE)\n      write.xlsx2(downloads()$dat.S, con, sheetName=\"edu_neg_G2_foci\", row.names=FALSE,append = TRUE)\n      write.xlsx2(downloads()$edu_pos_foci, con, sheetName=\"edu_pos_foci\", row.names=FALSE,append = TRUE)\n      write.xlsx2(downloads()$edu_pos_int, con, sheetName=\"edu_pos_nuclear_int\", row.names=FALSE, append = TRUE)\n      write.xlsx2(downloads()$edu_neg_g1_int, con, sheetName=\"edu_neg_G1_int\", row.names=FALSE,append = TRUE)\n      write.xlsx2(downloads()$edu_neg_S_int, con, sheetName=\"edu_neg_G2_int\", row.names=FALSE,append = TRUE)\n\n      \n    }\n  )\n  \n  ###/download data###\n  \n  \n}  \n\n\n# Run the application \nshinyApp(ui = ui, server = server)",
    "created" : 1531174271809.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3078663577",
    "id" : "898C4C43",
    "lastKnownWriteTime" : 1533225849,
    "last_content_update" : 1533225849324,
    "path" : "~/Documents/INCELL_foci_intensity_number_automatedAnalysis_R/splitCell/app.R",
    "project_path" : "splitCell/app.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}